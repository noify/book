# 关于DOM级别
 
> DOM0级标准是不存在的，所谓的DOM0级是DOM历史坐标中的一个参照点而已
 
0. DOM0级指的是IE4和Netscape 4.0这些浏览器最初支持的DHTML
1. DOM1级（DOM Level 1）于1998年10月成为W3C的推荐标准。DOM1级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。
2. DOM2级在原来DOM的基础上又扩充了（DHTML一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。DOM1级中的DOM核心模块也经过扩展开始支持XML命名空间
3. DOM3级则进一步扩展了DOM，引入了以统一方式加载和保存文档的方法–在DOM加载和保存（DOM Load and Save）模块中定义；新增了验证文档的方法–在DOM验证（DOM Validation）模块中定义。DOM3级也对DOM核心进行了扩展，开始支持XML 1.0规范，涉及XML Infoset、XPath和XML Base。

## DOM0 element.on[type] = function(){}

  兼容性：全部支持
  e.target：直接触发事件的元素[IE8及以下不支持taget属性，使用e.srcElement代替]
  e.srcElement：直接触发事件的元素[FF不支持srcElement属性，使用e.target代替]
  e.currentTarget：绑定事件的元素[IE8及以下不支持currentTarget属性，使用this代替]
  this：同e.currentTarget[所有浏览器通用]

## DOM2 attachEvent
  兼容性：IE5-IE10支持，IE11不支持，ff不支持
  e.target：不支持该属性
  e.srcElement：直接触发事件的元素
  e.currentTarget：不支持该属性
  this：始终指向window，可以使用call/apply改变this指向
  element.attachEvent("on"+type,function(){ handler.apply(element,arguments); })

## DOM2 addEventListener
  兼容性：IE5-IE8不支持，IE9-IE11支持，ff支持，现代浏览器支持
  e.target：直接触发事件的元素
  e.srcElement：不支持该属性
  e.currentTarget：绑定事件的元素
  this：同e.currentTarget
 
# 事件模型及事件代理/委托
 
## 事件流
 
DOM2级事件模型中规定了事件流的三个阶段：捕获阶段、目标阶段、冒泡阶段，低版本IE（IE8及以下版本）不支持捕获阶段
 
* 捕获事件流：Netscape提出的事件流，即事件由页面元素接收，逐级向下，传播到最具体的元素。
 
* 冒泡事件流：IE提出的事件流，即事件由最具体的元素接收，逐级向上，传播到页面。
 
* 目前支持以addEventListener绑定事件的浏览器：FF、Chrome、Safari、Opera、IE9-11
 
* 目前支持以attachEvent绑定事件的浏览器：IE6-10
 
> 综合测试结果，preventDefault和returnValue的兼容性如下（T：支持该属性或事件且结果正确；F：不支持该属性或事件或结果不正确：—：不支持该事件绑定方式）
 
|函数名|    事件绑定方式    |事件流|    FF|    Chrome|    Opera|    Safari|    模拟IE8|    模拟IE9|    模拟IE10|    IE11|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|preventDetault()|    element.on[type] = fn|    冒泡|    T|    T    |T|    T|    F|    T|    T|    T|
||addEventListener()|    捕获|    T|    T|    T|    T|    —|    T|    T|    T|
|||冒泡|    T    |T    |T|    T    |—    |T|    T|    T|
||attachEvent()    |冒泡    |—    |—|    —|    —|    F|    F|    F|    —|
|returnValue=false|    element.on[type] = fn|    冒泡|    F|    T    |T|    T|    T|    F|    F|    F|
||addEventListener()|    捕获    |F|    T|    T|    T    |—    |F    |F    |F|
|||冒泡|    F|    T|    T|    T|    —|    F    |F|    F|
||attachEvent()|    冒泡|    —|    —|    —    |—|    T|    F|    F|    —|
 
## IE和W3C不同绑定事件解绑事件的方法有什么区别，参数分别是什么，以及事件对象e有什么区别
 
W3C：`target.addEventListener(event, listener, useCapture);`
 
`event`事件类型；`listener`事件触发时执行的函数；`useCapture`指定事件是否在捕获或冒泡阶段执行，为true时事件句柄在捕获阶段执行，为`false`（默认`false`）时，事件句柄在冒泡阶段执行。
 
```js
btn.addEventListener('click', function() {
//do something...
}, false)
```
 
对应的事件移除
 
```js
removeEventListener(event, function, capture/bubble)
```
 
IE：`target.attachEvent(type, listener);`
 
`type`字符串，事件名称，含`on`，比如`onclick`、`onmouseover`、`onkeydown`等。 `listener`实现了 `EventListener` 接口或者是 JavaScript 中的函数。
 
```js
btn.attachEvent('onclick', function() {
//do something...
})
```
 
对应的事件移除

```js
detachEvent(event, function)
```


## 实现事件模型`events`
 
大致实现思路就是创建一个类或是匿名函数，在bind和trigger函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表，bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有，那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。
 
```js
var Emitter=function(){
    this._listeners = {} }
//注册事件
Emitter.prototype.on = function(eventName, callback) {
     var listeners = this._listeners[eventName]||[]
     listeners.push(callback)
     this._listeners[eventName]=listeners
}
//触发事件
Emitter.prototype.emit = function(eventName) {
    var args = Array.prototype.slice.apply(arguments).slice(1),
        listeners = this._listeners[eventName],
        self = this
    if (!Array.isArray(listeners))
        return
    listeners.forEach(function(callback) {
        try{
            callback.apply(this,args)
        } catch(e) {
            console.error(e)
        } 
    })
}
//实例
var emitter = new Emitter()
emitter.on('event', function(arg1, arg2){
    console.log('get event',arg1,arg2)
})
console.log('emit event')
emitter.emit('event', 'arg1', 'arg2')
```
 
 
 
## 事件如何派发也就是事件广播（dispatchEvent）
 
一般我们在元素上绑定事件后，是靠用户在这些元素上的鼠标行为来捕获或者触发事件的，或者自带的浏览器行为事件，比如click，mouseover，load等等，有些时候我们需要自定义事件或者在特定的情况下需要触发这些事件。这个时候我们可以使用IE下fireEvent方法，高级浏览器（chrome,firefox等）有dispatchEvent方法。
 
ie下的例子：
 
```js
//document上绑定自定义事件ondataavailable
document.attachEvent('ondataavailable', function (event) {
    alert(event.eventType);
});
var obj=document.getElementById("obj");
//obj元素上绑定click事件
obj.attachEvent('onclick', function (event) {
alert(event.eventType);
});
//调用document对象的createEventObject方法得到一个event的对象实例。
var event = document.createEventObject();
event.eventType = 'message';
//触发document上绑定的自定义事件ondataavailable
document.fireEvent('ondataavailable', event);
//触发obj元素上绑定click事件
document.getElementById("test").onclick = function () {
    obj.fireEvent('onclick', event);
};
```
 
高级浏览器（chrome,firefox等）的例子：
 
```js
//document上绑定自定义事件ondataavailable
document.addEventListener('ondataavailable', function (event) {
    alert(event.eventType);
}, false);
var obj = document.getElementById("obj");
//obj元素上绑定click事件
obj.addEventListener('click', function (event) {
    alert(event.eventType);
}, false);
//调用document对象的 createEvent 方法得到一个event的对象实例。
var event = document.createEvent('HTMLEvents');
// initEvent接受3个参数：
// 事件类型，是否冒泡，是否阻止浏览器的默认行为
event.initEvent("ondataavailable", true, true);
event.eventType = 'message';
//触发document上绑定的自定义事件ondataavailable
document.dispatchEvent(event);
var event1 = document.createEvent('HTMLEvents');
event1.initEvent("click", true, true);
event1.eventType = 'message';
//触发obj元素上绑定click事件
document.getElementById("test").onclick = function () {
    obj.dispatchEvent(event1);
};
 
```